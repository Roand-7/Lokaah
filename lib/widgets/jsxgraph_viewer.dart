import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:webview_flutter/webview_flutter.dart';
// Import platform-specific implementations
import 'package:webview_flutter_android/webview_flutter_android.dart';
import 'package:webview_flutter_wkwebview/webview_flutter_wkwebview.dart';

/// JSXGraph Viewer Widget
/// Renders AI-generated interactive geometry visualizations from True AI Oracle
/// 
/// Features:
/// - Interactive geometry manipulation
/// - Real-time student interaction tracking
/// - VEDA hint integration (highlight elements, add annotations)
/// - Mobile-optimized touch controls
/// - Answer extraction from graph state
class JSXGraphViewer extends StatefulWidget {
  /// JSXGraph code generated by AI Oracle
  final String? jsxCode;
  
  /// Graph bounding box [x1, y1, x2, y2]
  final List<double>? boundingBox;
  
  /// Show coordinate axes
  final bool showAxis;
  
  /// Show grid
  final bool showGrid;
  
  /// Visual theme: 'default', 'success', 'warning', 'error'
  final String theme;
  
  /// Callback for student interactions (point moves, clicks, etc.)
  final Function(Map<String, dynamic>)? onInteraction;
  
  /// Callback for errors
  final Function(String)? onError;
  
  /// Callback when graph is ready
  final VoidCallback? onReady;

  const JSXGraphViewer({
    Key? key,
    this.jsxCode,
    this.boundingBox = const [-10, 10, 10, -10],
    this.showAxis = true,
    this.showGrid = true,
    this.theme = 'default',
    this.onInteraction,
    this.onError,
    this.onReady,
  }) : super(key: key);

  @override
  State<JSXGraphViewer> createState() => JSXGraphViewerState();
}

class JSXGraphViewerState extends State<JSXGraphViewer> {
  late final WebViewController _controller;
  bool _isReady = false;
  String? _error;

  @override
  void initState() {
    super.initState();
    _initWebView();
  }

  void _initWebView() {
    // Platform-specific params
    late final PlatformWebViewControllerCreationParams params;
    if (WebViewPlatform.instance is WebKitWebViewPlatform) {
      params = WebKitWebViewControllerCreationParams(
        allowsInlineMediaPlayback: true,
        mediaTypesRequiringUserAction: const <PlaybackMediaTypes>{},
      );
    } else {
      params = const PlatformWebViewControllerCreationParams();
    }

    final WebViewController controller =
        WebViewController.fromPlatformCreationParams(params);

    controller
      ..setJavaScriptMode(JavaScriptMode.unrestricted)
      ..setBackgroundColor(const Color(0x00000000))
      ..setNavigationDelegate(
        NavigationDelegate(
          onProgress: (int progress) {
            debugPrint('JSXGraph loading: $progress%');
          },
          onPageStarted: (String url) {
            debugPrint('JSXGraph page started: $url');
          },
          onPageFinished: (String url) {
            debugPrint('JSXGraph page finished: $url');
            _loadGraph();
          },
          onWebResourceError: (WebResourceError error) {
            final errorMsg = 'Failed to load graph: ${error.description}';
            setState(() {
              _error = errorMsg;
            });
            if (widget.onError != null) {
              widget.onError!(errorMsg);
            }
          },
        ),
      )
      ..addJavaScriptChannel(
        'FlutterChannel',
        onMessageReceived: (JavaScriptMessage message) {
          _handleMessage(message.message);
        },
      );

    // Platform-specific settings
    if (controller.platform is AndroidWebViewController) {
      AndroidWebViewController.enableDebugging(true);
      (controller.platform as AndroidWebViewController)
          .setMediaPlaybackRequiresUserGesture(false);
    }

    // Load local HTML file
    controller.loadFlutterAsset('assets/jsxgraph_template.html');

    _controller = controller;
  }

  void _loadGraph() {
    if (widget.jsxCode == null || widget.jsxCode!.isEmpty) {
      debugPrint('No JSX code provided, skipping graph initialization');
      return;
    }

    final config = {
      'jsxCode': widget.jsxCode,
      'boundingBox': widget.boundingBox ?? [-10, 10, 10, -10],
      'axis': widget.showAxis,
      'grid': widget.showGrid,
      'theme': widget.theme,
    };

    final configJson = jsonEncode(config);
    final jsCall = 'initGraph(${jsonEncode(configJson)})';

    debugPrint('Loading graph with config: $configJson');
    _controller.runJavaScript(jsCall);
  }

  void _handleMessage(String message) {
    try {
      final data = jsonDecode(message);
      final type = data['type'];

      debugPrint('JSXGraph message: $type');

      switch (type) {
        case 'ready':
          debugPrint('JSXGraph engine ready');
          break;

        case 'domReady':
          debugPrint('JSXGraph DOM ready');
          break;

        case 'initialized':
          setState(() => _isReady = true);
          debugPrint('JSXGraph initialized with ${data['data']['objectCount']} objects');
          if (widget.onReady != null) widget.onReady!();
          break;

        case 'pointMoved':
        case 'boardClicked':
        case 'elementAdded':
          debugPrint('Interaction: $type - ${data['data']}');
          if (widget.onInteraction != null) {
            widget.onInteraction!(data['data']);
          }
          break;

        case 'error':
          final errorMsg = data['data']['message'];
          setState(() => _error = errorMsg);
          debugPrint('JSXGraph error: $errorMsg');
          if (widget.onError != null) widget.onError!(errorMsg);
          break;
      }
    } catch (e) {
      debugPrint('Error handling message: $e');
    }
  }

  /// Get current state of interactive elements for answer verification
  /// 
  /// Returns a map containing positions of all moveable points, lines, circles
  /// Used by VEDA to verify student's graphical answer
  Future<Map<String, dynamic>?> getGraphState() async {
    if (!_isReady) {
      debugPrint('Graph not ready, cannot get state');
      return null;
    }

    try {
      final result =
          await _controller.runJavaScriptReturningResult('getGraphState()');
      if (result is String) {
        return jsonDecode(result);
      }
    } catch (e) {
      debugPrint('Error getting graph state: $e');
    }
    return null;
  }

  /// Update graph dynamically (for adaptive hints from VEDA)
  /// 
  /// Example: When student is struggling, VEDA can add visual hints
  /// by injecting additional JSXGraph code
  void updateGraph(String newJsxCode) {
    if (!_isReady) {
      debugPrint('Graph not ready, cannot update');
      return;
    }

    final config = {
      'jsxCode': newJsxCode,
      'boundingBox': widget.boundingBox,
      'axis': widget.showAxis,
      'grid': widget.showGrid,
      'theme': widget.theme,
    };

    final jsCall = 'initGraph(${jsonEncode(jsonEncode(config))})';
    _controller.runJavaScript(jsCall);
  }

  /// Highlight a specific element on the graph (for hints)
  /// 
  /// Used by VEDA to draw attention to relevant parts
  void highlightElement(String elementId, {Color? color}) {
    if (!_isReady) return;

    final colorHex = color != null
        ? '#${color.value.toRadixString(16).substring(2)}'
        : '#f39c12';

    _controller.runJavaScript(
        'highlightElement("$elementId", "$colorHex")');
  }

  /// Add text annotation to the graph (for VEDA hints)
  /// 
  /// Example: "Check this angle" at coordinate (2, 3)
  void addAnnotation(double x, double y, String text, {Color? color}) {
    if (!_isReady) return;

    final colorHex = color != null
        ? '#${color.value.toRadixString(16).substring(2)}'
        : '#e74c3c';

    final jsCall =
        'addAnnotation($x, $y, ${jsonEncode(text)}, "$colorHex")';
    _controller.runJavaScript(jsCall);
  }

  @override
  Widget build(BuildContext context) {
    if (_error != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, color: Colors.red, size: 64),
              const SizedBox(height: 16),
              Text(
                'Graph Error',
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                      color: Colors.red,
                      fontWeight: FontWeight.bold,
                    ),
              ),
              const SizedBox(height: 8),
              Text(
                _error!,
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.bodyMedium,
              ),
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: () {
                  setState(() => _error = null);
                  _controller.reload();
                },
                icon: const Icon(Icons.refresh),
                label: const Text('Retry'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.red,
                  foregroundColor: Colors.white,
                ),
              ),
            ],
          ),
        ),
      );
    }

    return Stack(
      children: [
        WebViewWidget(controller: _controller),
        if (!_isReady)
          Container(
            color: Colors.white,
            child: const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text('Loading interactive graph...'),
                ],
              ),
            ),
          ),
      ],
    );
  }

  @override
  void dispose() {
    super.dispose();
  }
}
